/****

Name: Shivankit Gaind

ID: 2015A7PS0076P

****/


/********************************************************************************************************************

Assume that sizeexp - @m can't be a part of an arithmetic expression but function call can be


********************************************************************************************************************/


#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <math.h>

#include "codeGen.h"
#include "optimizer.h"
#include "intermediateCode.h"
#include "typeExtractor.h"
#include "semanticAnalyzer.h"
#include "symbolTable.h"
#include "ast.h"
#include "parser.h"
#include "Stack.h"
#include "NaryTree.h"
#include "lookUpTable.h"
#include "lexer.h"



int main(int argc, char* argv[]){

	if(argc!=3){
		printf("Check command: ./compiler testcaseX.txt code.asm\n");
		return 0;
	}

	char* grammar_file = "grammar.txt";


	printf("\n\nIMPLEMENTATION DETAILS: STAGE 1\n");
	printf("\t==> Dynamically load grammar from 'grammar.txt' file\n");
	printf("\t==> FIRST and FOLLOW set automated by algorithm(code)\n");
	printf("\t==> Both lexical and syntax analysis modules implemented\n");
	printf("\t==> Modules work with all the test cases\n");
	printf("\t==> Both lexer and parser recover from errors in 'testcase5.txt'");

	printf("\n\nIMPLEMENTATION DETAILS: STAGE 2\n");
	
	printf("\t==> AST created and irrelevant Parse Tree Nodes are freed\n");
	
	printf("\t==> Symbol Table working Properly assuming\n");
	printf("\t\t a. Symbol Table entries are only for the declared variables\n");
	printf("\t\t b. Uninitialized strings and matrices have a symbol width of zero\n");
	
	printf("\n\t==> Semantic Errors are identified properly assuming\n");
	printf("\t\t a. If Matrix or String are passed as input/output parameters in function definition/call, this is reported as semantic error\n");
	printf("\t\t b. A function call is valid only if it's definition is there in the current scope and it's not recursive. Even if a function's definition is there in the parent scope, it's not visible inside the child's scope\n");
	printf("\t\t c. Same error can lead to multiple errors, Eg, an undeclared variable can lead to 'undeclared variable error' as well as 'invalid rhs for assignment statement error' in the same line\n");
	
	printf("\n\n\t==> Intermediate Code generation working properly and Intermediate Code Quadruples are also printed (on Console) on selecting option 7\n");
	printf("\t==> An optimizer is also implemented for better code generation based on the static properties of the AST\n");

	printf("\n\n\t==> Code generation working properly assuming\n");
	printf("\t\t a. No function calls or function definitions are there in the code\n");
	printf("\t\t b. Assignment statements or any expressions involving REAL datatype entities can give errors or even seg faults because NASM can't handle Floating Point Numbers\n");
	printf("\t\t c. Code  generation couldn't handle read() statements, so if read(d) occurs and d is an integer, d is automatically assigned to 0 if it's uninitialized; otherwise previous value stays\n");


	printf("\n\n**************************** LEVEL 4: Symbol table/ Type Checker and Extractor/ AST/ Semantic Rules modules work.**************************\n\n");




	/****************************************Implementation Starts*****************************************/

	printf("\n\nStart Implementing the compiler\n\n");

	Grammar* grm = load_grammar_from_text_file(grammar_file);
	printf("-------Grammar loaded into the data structure-------\n\n");


	FirstAndFollow* sets = ComputeFirstAndFollowSets(grm);
	printf("-------First and Follow Sets Created-------\n\n");

	ParsingTable* table = initialize_Table();
	createParseTable(grm,sets,table);
	printf("-------Parsing Table Created-------\n\n");

	ParseTree* tree;

	AST* ast;

	SymTableTree* symTableTree;

	int parsed = 0;
	int syntax_errors = 0;
	int ast_built = 0;
	int semantic_errors = 0;

	TupleList* tuples;
	
	int exit_loop = 0;


	/********************************************** UI *****************************************************/

	while(1){

		printf("\nEnter the task you want to perform:\n\n");
		printf("0: For exiting from loop\n");
		printf("1: For printing the token list generated by the lexer (on the console)\n");
		printf("2: For parsing to verify the syntactic correctness of the input source code and to produce parse tree (On Console) printing all errors line wise\n");
		printf("3: For printing the Abstract Syntax Tree in appropriate format (On Console). Traversal: Preorder - First node, then all children \n");
		printf("4: For displaying the amount of allocated memory and number of nodes to each of parse tree and abstract syntax tree\n");
		printf("5: For printing the Symbol Table\n");
		printf("6: For compiling to verify the syntactic and semantic correctness both of the input source code\n");
		printf("7: For producing assembly code (only when there is no syntactic, semantic or type mismatch errors)\n");


		printf("\n\nYour Input: ");



		int choice;
		scanf("%d",&choice);

		
		switch(choice){

			case 0:{
				exit_loop = 1;
			}break;

			case 1:{
				printTokenList(argv[1]);				
			}break;

			case 2:{
				printf("\n\n---------------------------------Parsing Begins-----------------------------------\n");				
				tree = parseInputSourceCode(argv[1],table,&syntax_errors);		

				if(tree!=NULL){
					parsed = 1;
					printf("\n\n----------------------------File Closed-----------------------------------\n");
					printf("\n\n--------------------------Parse Tree Built -------------------------------\n\n\n");
				}
				else{
					parsed = 0;
				}

				if(parsed==0){
					printf("\n\nParse Tree Not Built yet: Wrong File Name Passed\n\n");
				}
				else{
					int ch;
					printf("Do you want to print the Parse Tree : '1' for YES and '0' for NO: ");
					scanf("%d",&ch);
					if(ch==1)
						printParseTree(tree);				
				}
			}break;

			case 3:{
				if(parsed==0){
					printf("\n\n------------------Parse Tree not Built yet: Select '2' First-----------------\n\n");
				}
				else{
					if(syntax_errors==1){
						printf("\n\nAST can't be constructed since the code has Syntax Errors\n\n");
					}
					else{
						printf("\n\n----------------------------------Generating AST----------------------------------\n\n");
						ast = generateAST(tree);
						printf("\n\n-----------------------------------Printing AST (Node first, and then children)----------------------------------\n\n");
						printAST(ast);
						printf("\n\n----------------------------AST Printed in Preorder Fashion (Node first, and then children)----------------------------\n\n");

						ast_built = 1;
					}
				}
			}break;

			case 4:{
				if(ast_built==0){
					printf("\n\n---------------------AST not Built yet: Select '3' First-------------------\n\n");
				}
				else{
					print_compression_ratio(tree, ast);
				}
			}break;


			case 5:{
				if(ast_built==0){
					printf("\n\n---------------------AST not Built yet, so Symbol Table can't be constructed: Select '3' First-------------------\n\n");
				}
				else{
					//Initialize Error List
					ErrorList* errors = initialize_errors();

					//Building Symbol Table
					SymTableTree* symtree = buildAllSymbolTables(ast,errors);

					//So that offsets can be set
					semantic_analyzer(ast,errors,symtree);

					//Printing Symbol Table Tree
					printSymbolTableTree(symtree);

				}
			}break;

			case 6:{
				syntax_errors = 0;
				semantic_errors = 0;
				tree = parseInputSourceCode(argv[1],table,&syntax_errors);	

				if(tree==NULL){
					printf("\n\nParse Tree Not Built yet: Wrong File Name Passed\n\n");
				}
				else{
					if(syntax_errors==1){
						printf("\n\n------------------------Syntax Errors Reported-----------------------\n\n");
					}
					else{
						printf("\n\n---------------------------Semantic Analysis Begins---------------------------\n\n");
						ast = generateAST(tree);
						ErrorList* errors = initialize_errors();
						SymTableTree* symtree = buildAllSymbolTables(ast,errors);
						semantic_analyzer(ast,errors,symtree);

						if(errors->head!=NULL){
							semantic_errors = 1;
							print_errors(errors);
							printf("\n\n------------------------Semantic Errors Reported -------------------------\n\n");

						}
						else{
							printf("\n\n------------------No syntax or semantic errors----------------\n\n");
						}
					}
				}

			}break;

			case 7:{

				syntax_errors = 0;
				semantic_errors = 0;
				tree = parseInputSourceCode(argv[1],table,&syntax_errors);	

				if(tree==NULL){
					printf("\n\nParse Tree Not Built yet: Wrong File Name Passed\n\n");
				}
				else{
					if(syntax_errors==1){
						printf("\n\n------------------------Syntax Errors Reported : Unsuccessful Compilation-----------------------\n\n");
					}
					else{
						printf("\n\n---------------------------Semantic Analysis Begins---------------------------\n\n");
						ast = generateAST(tree);
						ErrorList* errors = initialize_errors();
						SymTableTree* symtree = buildAllSymbolTables(ast,errors);
						semantic_analyzer(ast,errors,symtree);

						if(errors->head!=NULL){
							semantic_errors = 1;
							print_errors(errors);

							printf("\n\n------------------------Semantic Errors Reported : Unsuccessful Compilation-----------------------\n\n");

						}
						else{
							//Code Generation
							printf("\n\n------------------Compilation Successful----------------\n");
							tuples = generateIR(ast);

							printf("\n\n------------------Generating Final Code----------------\n");
							generate_code(tuples,argv[2]);
							printf("\n\n-------------------ASM Code Generated----------------\n");
						}
					}
				}

			}break;

		}

		if(exit_loop)
			break;

	}

	return 0;
}


